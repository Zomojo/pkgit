#!/usr/bin/env sh

# Publish a package using the spec file in the current directory
umask 0002

usage()
{
cat <<EOF
Usage: $(basename $0) [-h|--help] [--debug] [--version] [--sandbox] [--unclean] [-v|--verbose] [-p|--pretend] [-m|--message=<meaningful message>]

Publish a package using the spec file in the current directory

Options:
  -h|--help  Print this message
  --debug  Executes "set -x" to put the shell into debug mode
  --version  Print the version number and exit
  --sandbox  Don't tag the central repo, don't worry if we are off the master branch, don't worry if we are ahead of the central repo.  Use 888.888.888-888 as the version-release number
  --unclean  Package up without checking that files are checked in.  This implies --sandbox. Note that --sandbox still wants you to check your work in to the local repo and this lets you work around that restriction.
  -v|--verbose  Print out extra information rather than showing nothing
  -p|--pretend  Do all the work but don't actually execute the git tag command. Works best in conjunction with --verbose
  -m|--message  The message to be put into the annotated tag.  Defaults to "Tagging in preparation for packaging"
  
Examples:
$(basename $0) -m "The Heisenbug is gone."
        
EOF
   
exit 0
}

die()
{
    echo >&2 "$@"
    exit 1
}

verbose_echo()
{
    if [ -n "$verbose" ]; then
        echo "$@"
    fi
}

# Parse command line arguments. We accept the usual GNU short and long args and convert them to space separated arguments
# Note that we use `"$@"' to let each command-line parameter expand to a separate word. The quotes around `$@' are essential!
# We need TEMP as the `eval set --' would nuke the return value of getopt.
TEMP=$(getopt -s sh -o hvqpm: -l "help,debug,version,verbose,quiet,pretend,message:,sandbox,unclean" -n "$(basename $0)" -- "$@")
if [ $? != 0 ] ; then echo "Could not parse command line options..." >&2 ; usage ; fi
eval set -- "$TEMP"  # Note the quotes around '$TEMP': they are essential!

message="Tagging in preparation for packaging"
verbose="--verbose"   # Be verbose by default.  The users seem to prefer that rather than complete silence

# Overide the defaults with anything from the command line
while true; do
    case "$1" in
        "--debug"         )  set -x;debug="--debug" ;;
        "-h"|"--help"     )  usage ;;
        "--version"       )  echo PKGIT_PROJECT_VERSION; exit 0 ;;
        "--verbose"       )  verbose="--verbose" ;;
        "--quiet"         )  unset verbose ;;
        "-p"|"--pretend"  )  pretend="--pretend" ;;
        "-m"|"--message"  )  shift; message="$1" ;;
        "--sandbox"       )  sandbox="--sandbox" ;;
        "--unclean"       )  unclean="--unclean"; sandbox="--sandbox" ;;
        "--"              )  shift ; break ;;
        *                 )  die "getopt error!" ; exit 1 ;;
    esac
    shift
done

# Check that one and only one spec file exists
spec=$(ls -1 *.spec 2> /dev/null)
if [ "$spec" = "" ]; then
    die "$(basename $0) will only work if there is exactly one spec file in the current directory.  An example spec file can be created with pkgit-create-skeleton-spec-file."
fi
verbose_echo "Found spec file = $spec"

# Check we are in a git repo
git status >/dev/null 2>&1
if [ $? != 0 ]; then
    die "Cannot run this script outside of a git repository"
fi

# If only doing a sandbox build then we don't need to check that we are on the master branch 
if [ -z "$sandbox" ]; then
    # Refuse to package if we aren't on branch master and there isn't an exact tag describing the sha1.  May remove this limitation in the future
    current_branch=$(git branch |grep '*'|cut -d' ' -f2-)
    if [ "$current_branch" != "master" ]; then
        exact_tag=$(git describe --tags --match='*-*.*.*-*' --exact 2>/dev/null)
        if [ $? != 0 ]; then
            die "Refusing to publish: not on branch master and no exact tag describing where we are.  Try 'git checkout master' before using pkgit again"
        fi
    fi
fi

# Normally insist that all files are checked in, but if the user specifies "unclean" then skip the checks
if [ -z "$unclean" ]; then
    # Refuse to package if there are untracked files (if .gitignore knows about them then it is OK to proceed)
    if [ $(git clean -d -n | wc -l) != 0 ]; then
        echo >&2 "Refusing to publish: the following files are currently untracked by git: "
        git clean -d -n |sed 's/Would remove /\t/g'
        die "Please commit them, stash them, add them to a .gitignore or remove them."
    fi

    # Disallow unstaged changes in the working tree
    git diff --name-status --ignore-submodules --exit-code 2>&1 >/dev/null
    if [ $? != 0 ] ; then
        echo >&2 "Refusing to publish: you have unstaged changes."
        git diff --name-status --ignore-submodules >&2
        die "Please commit them, stash them or remove them."
    fi

    # Disallow uncommitted changes in the staging area
    git diff --staged --quiet --ignore-submodules --exit-code 2>&1 >/dev/null
    if [ $? != 0 ]; then
        echo >&2 "Refusing to publish: your staging area contains uncommitted changes."
        git diff --staged --name-status --ignore-submodules >&2
        die "Please commit them or remove them from the staging area."
    fi
fi

# If only doing a sandbox build then we don't need to check that all has been pushed to the central repo
if [ -z "$sandbox" ]; then
    # Refuse to package if the local git repo is ahead of the central repo
    # Note that the other way around is OK.  That is, the central repo may be in advance of the local repo.
    # Make the assumption that if branch is not master (so on a detached HEAD or some other branch) then the user actually knows what they are doing
    if [ "$current_branch" = "master" ]; then
        count_ahead=$(git log origin/master..HEAD --format=oneline |wc -l)
        if [ $count_ahead -gt 0 ]; then
            die "Refusing to publish: Your branch is ahead of 'origin/master' by $count_ahead commit(s). Please push these commits to the central repo before attempting to package." 
        fi
    fi
fi

# Time to tag the repo.
if [ -z "$sandbox" ]; then
    tag_cmd="$(dirname $0)/pkgit-tag-next $debug --message=\"$message\" $pretend $verbose ${spec%.spec} |tail -1"
    verbose_echo "Calling $tag_cmd"
    tag_name=$(eval $tag_cmd)
    if [ $? != 0 ]; then
        die "Tagging unsuccessful.  Can't proceed. :("
    fi
else
    tag_name=${spec%.spec}-888.888.888-888
    verbose_echo "Sandbox version being created.  Assigned version = $tag_name"
fi    

# Extract the version, release from the tag_name
release=${tag_name##*-}                # Release is everything after the last minus sign.  Mostly this will be 1
version=${tag_name#${spec%.spec}-*}    # Remove the spec (package) name from the start; leaving something like 3.0.8-1
version=${version%-*}                  # Remove the release number from the end; leaving something like 3.0.8

# Release should be a number
TESTVAR="$(echo "$release" | sed 's/[0-9]*//g' )"
[ "${TESTVAR}"x = ""x ] || die "Illegal release number: $release"

# Version should be number.number.number
TESTVAR="$(echo "$version" | sed 's/[0-9]*//g' )"
[ "${TESTVAR}"x = ".."x ] || die "Illegal version number: $version"

verbose_echo "Tag name:           $tag_name"
verbose_echo "Spec file:          $spec"
verbose_echo "Version:            $version"
verbose_echo "Release:            $release"
verbose_echo ""

# Normally insist that all files are checked in, but if the user specifies "unclean" then skip the checks
if [ -z "$unclean" ]; then
    if [ -n "$pretend" ]; then
        echo "Pretend mode can go no further.  Aborting."
    fi

    count=$(git clean -x -n -d |wc -l)
    if [ $count -gt 0 ]; then
        echo ^^^^^^ WARNING ^^^^^^
        echo If you proceed you
        git clean -x -n -d
        echo
        echo "Proceed (y/N)"
        read user_choice
        if [ $user_choice = "Y" ] || [ $user_choice = "y" ]; then
            echo "Cleaning out any uncommitted files..."
            git reset --hard
            git clean -x  -f -d
        else
            exit 1
        fi
    fi
fi

# Figure out some information about the repository and project spec file for later use
current_repo_root=$($(dirname $0)/pkgit-find-repo-root)
current_specfile_path=$(pwd)
# Note that the character after the 's' in the sed command is defined by sed to be the command separator character. i.e., you don't have to use '/'
relative_project_path=$(echo $current_specfile_path | sed "s^${current_repo_root}/*^^g")   
repopath=$(git remote show origin |head -n 2 |tail -n1|sed 's/Fetch URL:/git clone/g')
spec_repopath="$repopath yourreponame \&\& cd yourreponame/${relative_project_path} \&\& git checkout $tag_name"


#
# Now make the package
#

# At this point in time we will only support the source gzipped tarball with the .tgz extension
grep Source: $spec |grep tgz >/dev/null
if [ $? = 1 ]; then
    die "At this point in time we will only support the source gzipped tarball with the .tgz extension"
fi

#top_level_build_dir=$(mktemp -d)
top_level_build_dir="$HOME"

# Do not build in the root dir of the filesystem 
if [ $top_level_build_dir = "/" ]; then
    die "Refusing to build with when the top level build directory is /"
fi

verbose_echo "Building in $top_level_build_dir"
rpmhome=$top_level_build_dir/rpmbuild 
mkdir -p $rpmhome  || die "Could not make the $rpmhome directory"
cd $rpmhome  >/dev/null 
rpmdev-setuptree  || die "Failed to create the expected rpmbuild expected directory structure"

# copy the almost complete spec file from the project dir to the rpmbuild dir and fill in the missing bits
verbose_echo "Copying spec file and inserting correct version numbers and package source into spec file"
cp $current_specfile_path/$spec $rpmhome/SPECS/
sed -i "s/%{*version_base}*/$version/" $rpmhome/SPECS/$spec
verbose_echo "Inserting version = $version"
sed -i "s/%{*version_release}*/$release/" $rpmhome/SPECS/$spec
verbose_echo "Inserting release = $release"
sed -i "s|\(%{*description}*.*\)|\1\nPackage Source: $spec_repopath\n|g" $rpmhome/SPECS/$spec
verbose_echo "Inserting Package Source: $spec_repopath"
sed -i "s|%{*projectdir}*|$relative_project_path|g" $rpmhome/SPECS/$spec
verbose_echo "Inserting %projectdir = $relative_project_path"

# rpmbuild expects to find the files in a tarball with the package-version as the top level directory.
mkdir -p $rpmhome/tmp  || die "Could not create a temp directory to build the tarball in"
cd $rpmhome/tmp >/dev/null 

# Copy over all the files for the given project  
# Assume we need all files in the current directory and subdirectories  
rpmbuild_tmp_project_dir=$rpmhome/tmp/${tag_name%-*}
mkdir -p $rpmbuild_tmp_project_dir  || die "Could not create a specific project directory to build the tarball in"
cd $current_specfile_path >/dev/null 
repo_root=$($(dirname $0)/pkgit-find-repo-root)
cd $rpmbuild_tmp_project_dir >/dev/null     

relative_specfile_path=${current_specfile_path#$repo_root}
mkdir -p $rpmbuild_tmp_project_dir/$relative_specfile_path/  || die "Could not create $relative_specfile_path to build the tarball in"
if [ -n $verbose ]; then rsync_options="-vv"; else rsync_options="--quiet";fi
rsync -a $rsync_options "$current_specfile_path/" $rpmbuild_tmp_project_dir/$relative_specfile_path/

#copy in the modified spec file
cp $rpmhome/SPECS/$spec $rpmbuild_tmp_project_dir/$relative_specfile_path/

if [ -e $current_specfile_path/build.sh ] && [ $(grep -c cake $current_specfile_path/build.sh) -gt 0 ]; then    
    # This is the complex packaging case where needed files also exist in directories above and sideways from this project directory
    verbose_echo "Using cake to generate the dependencies for the tarball"
    
    # Since cake is available, use it to find the files required to package
    touch $rpmbuild_tmp_project_dir/.git    # This is so cake can find a "git repo" even when there isn't really one

    cd $current_specfile_path >/dev/null 
    ./build.sh --file-list --quiet | while read next_file; do
        newfilename=${next_file#$repo_root}
        mkdir -p $(dirname $rpmbuild_tmp_project_dir/$newfilename)
        cp $repo_root/$next_file $rpmbuild_tmp_project_dir/$newfilename
    done 
fi

verbose_echo "Building tarball"
cd $rpmhome/tmp >/dev/null 
tar -cvzf $rpmhome/SOURCES/${tag_name%-*}.tgz . >/dev/null 2>&1


cd $rpmhome  >/dev/null 
rm -rf $rpmhome/tmp

# build RPM
verbose_echo "Building RPM with rpmbuild"
cd $rpmhome/SPECS  >/dev/null
rpmbuild --clean --quiet -ba $(basename $spec)
cd $rpmhome >/dev/null

# move the newly built rpms to the project directory
find -name "${spec%.spec}*$version-$release*.rpm" -exec mv {} $current_specfile_path \;  >/dev/null

cd $current_specfile_path  >/dev/null







